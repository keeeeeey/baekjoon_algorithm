import sys
sys.setrecursionlimit(10 ** 6)

# 스택(stack)의 특성
# 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.
# 스택은 저장된 자료는 선형 구조를 갖는다.
# - 선형구조 : 자료 간의 관계가 1대1의 관계를 갖는다.
# - 비선형구조 : 자료 간의 관계가 1대 N의 관계를 갖는다. (예 : 트리)
# 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
# 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO, Last-In-First-Out)이라고 부른다.
# - 예를 들어 스택에 1, 2, 3, 순으로 자료를 삽입한 후 꺼내면 역순으로 즉 3, 2, 1 순으로 꺼낼 수 있다.

# 자료구조 : 자료를 선형으로 저장할 저장소
# - 배열을 사용할 수 있다.
# - 저장소 자체를 스택이라 부르기도 한다.
# - 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.

# 연산 (push, pop, isEmpty, peek)
# - 삽입 : 저장소에 자료를 저장한다. 보통 push라고 부른다.
# - 삭제 : 저장소에서 자룔르 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부른다.
# - 스택이 공백인지 아닌지를 확인하는 연산. isEmpty
# - 스택의 top에 있는 item(원소)를 반환하는 연산. peek

# 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.

# 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다.
# 동적 연결리스트를 이용하여 구현하는 방법을 의미한다.
# 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가진다.

# Function call
# 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
# 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조
# 함수 호출이 발생하면 후출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
# 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
# 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.

# 재귀 호출
# 자기 자신을 호출하여 순환 수행되는것
# 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 가능

def factorial(n):
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))

def fibo(n):
    if n < 2:
        return n
    else:
        return fibo(n - 1) + fibo(n - 2)

print(fibo(10))

def f(i, N):
    if i == N:
        print(i)
        return
    else:
        print(i)
        f(i + 1, N)

f(0, 1000)

# 크기가 N인 배열의 모든 원소에 접근하는 재귀함수
def fn(i, N):
    if i == N:          # 배열을 벗어남
        return
    else:               # 남은 원소가 있는 경우
        B[i] = A[i]
        fn(i + 1, N)    # 다음 원소로 이동

N = 3
A = [1, 2, 3]
B = [0] * N
fn(0, N)                # 0번 원소부터 N개의 원소에 접근
print(B)

# 메모이제이션(Memoization)
# 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여
# 전체적인 실행속도를 빠르게 하는 기술이다. 동적 계획법의 핵심!!!!

# memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다.
# memo[0]을 0으로 memo[1]는 1로 초기화 한다.

def fibo1(n):
    global memo             # 없어도 됨, 새로운 리스트를 함수에 할당할때만 필요!! 그냥 값만 추가할때는 안써도 된다.
    if n >= 2 and len(memo) <= n:
        memo.append(fibo1(n - 1) + fibo1(n - 2))
    return memo[n]

memo = [0, 1]