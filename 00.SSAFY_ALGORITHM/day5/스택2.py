# 중위표기법(infix notation)
# 연산자를 피연산자의 가운데 표기하는 방법
# 예) A + B

# 후위표기법
# 연산자를 피연산자 뒤에 표기하는 방법
# 예) AB+

# step1. 중위 표기식의 후위 표기식 변환 방법1
# 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
# 각 연산자를 그에 대응하는 오른쪽괄호의 뒤로 이동시킨다.
# 괄호를 제거한다.

# 1. ((A * B) - (C / D))
# 2. ((A B) * (C D) / ) -
# 3. AB*CD/-

# step1. 중위 표기법에서 후위 표기법으로의 변환 알고리즘(스택 이용)2
# 입력 받은 중위 표기식에서 토큰을 읽는다.
# 토큰이 피연산자이면 토큰을 출력한다
# 토큰이 연산자(괄호포함)일 떄, 이 토큰이 스택의 top에 저장되어 있는 연산자보다
# 우선순위가 높으면 스택에 push하고, 그렇지 않다면 스택 top의 연산자의 우선순위가
# 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push한다.
# 만약 top에 연산자가 없으면 push한다.


# 중위연산식 ==> 후위연산식

n = int(input())    # 식의 길이(문자 갯수)
infix = input()     # 중위표기식을 문자열로 입력 받기

stack = [0] * n     # 스택의 길이는 최대 n
top = -1

# 연산자의 우선순위
icp = {"+" : 1, "-" : 1, "/" : 2, "*" : 2}

postfix = ""

# 중위연산식을 순회하면서 후위연산식으로 바꾸기
for i in range(n):
    # i 번째 문자를 하나 떼와서
    # 피연산자이면 ==> 출력, 연산자이면 우선순위 스택의 top과 비교
    if "0" <= infix[i] <= "9":      # 피연산자, 숫자인경우
        postfix += infix[i]
    else:
        # 연산자인 경우
        # 우선순위를 비교해서 스택의 top 의 원소와 지금 떼온 연산자와 우선순위를 비교
        # 우선순위가 같거나 높으면 pop
        while top > -1 and icp[stack[top]] >= icp[infix[i]]:
            # pop 시켜주고 문자열에 출력
            postfix += stack[top]
            top -= 1
        top += 1
        stack[top] = infix[i]

# 만약 스택 안에 연산자가 남아잇는 경우 수식 뒤에 붙여주기
while top > -1:
    postfix += stack[top]
    top -= 1

print(postfix)